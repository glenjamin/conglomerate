<% include head %>

<h1>Getting Started</h1>

<ul>
  <li>
    <a href="#setup">Setup</a>
    <ul>
      <li><a href="#requirements">Requirements</a></li>
      <li><a href="#connect">Connecting to AMQP</a></li>
      <li><a href="#subscribing">Subscribing to a queue</a></li>
      <li><a href="#publishing">Publishing to an exchange</a></li>
    </ul>
  </li>
  <li>
    <a href="#exercises">Exercises</a>
    <ul>
      <li><a href="#jobs">Markdown (Job Queue)</a></li>
      <li><a href="#chat">Chat (pub / sub)</a></li>
      <li><a href="#logs">Logs (event stream)</a></li>
      <li><a href="#ball">8 Ball (RPC)</a></li>
    </ul>
  </li>
  <li><a href="#extra">Extra Credit</a></li>
</ul>

<h2 id="setup">Setup</h2>

<h3 id="requirements">Requirements</h3>

<ul>
  <li>A text editor</li>
  <li>A terminal</li>
  <li>Ruby 1.9+</li>
</ul>
<pre>
gem install bunny
</pre>

<h3 id="connect">Connecting to AMQP</h3>

<p>Save the following into <kbd>connect.rb</kbd></p>

<pre>
require "rubygems"
require "bunny"

@bunny = Bunny.new '<%= amqp_url %>'
@bunny.start
</pre>

<p>You can then <kbd>require</kbd> this file into any others you write.</p>

<p>All communication with the server is done through a channel, you should
use a different channel for each 'thing' you want to do with the server.
to get a new channel use the following:</p>

<pre>
channel = @bunny.channel
</pre>

<p><a href="http://rubybunny.info/articles/connecting.html">More info</a></p>

<h3 id="subscribing">Subscribing to a queue</h3>

<p>A queue object can be obtained from a channel, declaring any options</p>

<pre>
# pre-existing queue
queue = channel.queue("queue-name", :no_declare => true)

# Our own queue
queue = channel.queue("my-queue", :auto_delete => true)

# Let the server generate a name
queue = channel.queue("", :exclusive => true)
</pre>

<p>If we have created the queue ourselves, we need to bind the queue to the
exchange to determine which messages we'll receive</p>

<pre>
queue.bind("exchange-name", :routing_key => "key.#")
queue.bind(exchange_object, :routing_key => "exact.key")
</pre>

<p>Once we have a queue, we set the prefetch size to ensure we're not too
greedy, and then <kbd>subscribe</kbd> to begin receiving messages.<br>
The <kbd>:block</kbd> parameter stops us using multiple threads, which makes
it easier to see the program flow in these examples.<br />
The <kbd>:ack</kbd> option tells the server we will be explicitly acknowledging
messages.</p>

<pre>
channel.prefetch 1
queue.subscribe(:block => true, :ack => true) do | info, metadata, body |
  # do some stuff
  channel.acknowledge(info.delivery_tag)
end
</pre>

<p><a href="http://rubybunny.info/articles/queues.html">More info</a></p>

<h3 id="publishing">Publishing to an exchange</h3>

<p>Similar to the queue example, we declare the exchange - of type "topic", and
then we can publish messages to it.</p>

<pre>
# pre-existing exchange
exchange = channel.topic("name", :no_declare => true)

# your own exchange
exchange = channel.topic("name", :durable => false)

# and now publish
exchange.publish("body", :routing_key => "key")
</pre>

<p><a href="http://http://rubybunny.info/articles/exchanges.html">More info</a></p>

<h2 id="exercises">Exercises</h2>

<h3 id="jobs">A job queue of markdown docs to convert to HTML</h3>

<ul>
  <li>Queue: documents.ready</li>
  <li>Routing Key: documents.ready</li>
  <li>Format <code>{ "destination": "&lt;url&gt;", "markdown": "&lt;markdown&gt;" }</code></li>
</ul>

<p>The provided markdown should be converted to HTML, and sent back to the url
provided via HTTP POST. An optional HTTP header of <kbd>Author</kbd> can be passed to
say who you are.</p>

<p>The results of recently completed jobs can be seen at <a href="/jobs">/jobs</a>, including the
author of each conversion.</p>

<h3 id="chat">A simple chat exchange</h3>

<ul>
  <li>Exchange: chat</li>
  <li>Queue: create your own</li>
  <li>Routing Key: anything (used as “room” name)</li>
  <li>Format <code>{ "name": "&lt;your name&gt;", "message": "&lt;message&gt;" }</code></li>
</ul>

<p>All messages published to this exchange can be viewed on the <a href="/chat">/chat</a> page.</p>

<p>You are free to publish to this exchange, or create your own queues to receive
messages.</p>

<h3 id="logs">All the logs from the application</h3>

<ul>
  <li>Exchange: logs</li>
  <li>Routing Keys: &lt;app&gt;.&lt;type&gt;.&lt;level&gt;</li>
  <li>Format: see https://github.com/trentm/node-bunyan</li>
</ul>

<h3 id="magic-8-ball-rpc">Magic 8 Ball RPC</h3>

<ul>
  <li>Exchange: 8ball</li>
  <li>Routing Key: 8ball</li>
  <li>Format: the message body is your question</li>
</ul>

<p>As mentioned in the slides, you’ll need to create a temporary queue for replies
<em>before</em> publishing the request. The published message should include the
<kbd>replyTo</kbd> and <kbd>correlationId</kbd> headers.</p>

<h2 id="extra">Extra Credit</h2>

<p>Here are a few suggestions for other things you could implement using the same
data in these scenarios</p>

<ul>
  <li>Try processing multiple jobs at the same time</li>
  <li>Try creating temporary queues on the chat exchange that are only bound to
  a single room</li>
  <li>Try different variations and combinations of bindings for the log exchange</li>
  <li>Experiment with different ways of displaying the information from the log exchange</li>
  <li>Try making multiple 8 ball requests in parallel, and correlating them back together after the replies come back</li>
</ul>

<p>Feel free to experiment with the server, create queues or exchanges, publish
or consume what you want. If you have any other ideas - try them out.</p>

<% include foot %>
