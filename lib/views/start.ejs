<% include head %>

<h1>Getting Started</h1>

<ul>
  <li>
    <a href="#setup">Setup</a>
    <ul>
      <li><a href="#requirements">Requirements</a></li>
      <li><a href="#connect">Connecting to AMQP</a></li>
      <li><a href="#subscribing">Subscribing to a queue</a></li>
      <li><a href="#publishing">Publishing to an exchange</a></li>
    </ul>
  </li>
  <li>
    <a href="#exercises">Exercises</a>
    <ul>
      <li><a href="#jobs">Markdown (Job Queue)</a></li>
      <li><a href="#chat">Chat (pub / sub)</a></li>
      <li><a href="#logs">Logs (event stream)</a></li>
      <li><a href="#ball">8 Ball (RPC)</a></li>
    </ul>
  </li>
  <li><a href="#extra">Extra Credit</a></li>
</ul>

<h2 id="setup">Setup</h2>

<h3 id="requirements">Requirements</h3>

<ul>
  <li>A text editor</li>
  <li>A terminal</li>
  <li>Ruby 1.9+</li>
</ul>
<pre>
gem install bunny
</pre>

<h3 id="connect">Connecting to AMQP</h3>

<p>Save the following into <kbd>connect.rb</kbd></p>

<pre>
require "rubygems"
require "bunny"

bunny = Bunny.new '<%= amqp_url %>'
bunny.start
</pre>

<p>You can then <kbd>require</kbd> this file into any others you write.</p>

<p>All communication with the server is done through a channel, you should
use a different channel for each 'thing' you want to do with the server.
to get a new channel use the following:</p>

<pre>
channel = bunny.channel
</pre>

<p><a href="http://rubybunny.info/articles/connecting.html">More info</a></p>

<h3 id="subscribing">Subscribing to a queue</h3>

<p>A queue object can be obtained from a channel, declaring any options</p>

<pre>
# pre-existing queue
queue = channel.queue("queue-name", :no_declare => true)

# Our own queue
queue = channel.queue("my-queue", :auto_delete => true)

# Let the server generate a name
queue = channel.queue("", :exclusive => true)
</pre>

<p>We need to bind the queue to the exchange to say what messages to get</p>

<pre>
queue.bind("exchange-name", :routing_key => "key.#")
queue.bind(exchange_object, :routing_key => "exact.key")
</pre>

<p>Once we have a queue, we set the prefetch size to ensure we're not too
greedy, and then <b>subscribe</b> to begin receiving messages.<br>
The <kbd>block</kbd> parameter stops us using multiple threads, which makes
it easier to see the program flow.<br />
The ack option decides whether we need to acknowledge messages.</p>

<pre>
channel.prefetch 1
queue.subscribe(:block => true, :ack => true) do | info, metadata, body |
  # do some stuff
  channel.acknowledge(info.delivery_tag)
end
</pre>

<p><a href="http://rubybunny.info/articles/queues.html">More info</a></p>

<h3 id="publishing">Publishing to an exchange</h3>

<p>Similar to the queue example, we declare the exchange - of type "topic", and
then we can publish messages to it.</p>

<pre>
# pre-existing exchange
exchange = channel.topic("name", :no_declare => true)

# your own exchange
exchange = channel.topic("name", :durable => false)

# and now publish
exchange.publish("body", :routing_key => "key")
</pre>

<p><a href="http://http://rubybunny.info/articles/exchanges.html">More info</a></p>

<h2 id="exercises">Exercises</h2>

<h3 id="jobs">A job queue of markdown docs to convert to HTML</h3>

<ul>
  <li>Exchange: jobs</li>
  <li>Queue: documents.ready</li>
  <li>Routing Key: documents.ready</li>
  <li>Format <code>{ "destination": "&lt;url&gt;", "markdown": "&lt;markdown&gt;" }</code></li>
</ul>

<p>The provided markdown should be converted to HTML, and sent back to the url
provided via HTTP POST. An optional HTTP header of ‘Author’ can be passed to
say who you are.</p>

<p>The results of recently completed jobs can be seen at <code>/jobs</code>, including the
author of each conversion.</p>

<h3 id="chat">A simple chat exchange</h3>

<ul>
  <li>Exchange: chat</li>
  <li>Queue: create your own</li>
  <li>Routing Key: anything (used as “room” name)</li>
  <li>Format <code>{ "name": "&lt;your name&gt;", "message": "&lt;message&gt;" }</code></li>
</ul>

<p>All messages published to this exchange can be viewed on the <code>/chat</code> page.</p>

<p>You are free to publish to this exchange, or create your own queues to receive
messages.</p>

<h3 id="logs">All the logs from the application</h3>

<ul>
  <li>Exchange: logs</li>
  <li>Routing Keys: &lt;app&gt;.&lt;type&gt;.&lt;level&gt;</li>
  <li>Format: see https://github.com/trentm/node-bunyan</li>
</ul>

<h3 id="magic-8-ball-rpc">Magic 8 Ball RPC</h3>

<ul>
  <li>Exchange: 8ball</li>
  <li>Routing Key: 8ball</li>
  <li>Format: the message body is your question</li>
  <li>Note: reply_to and correlation_id should be set</li>
</ul>

<% include foot %>